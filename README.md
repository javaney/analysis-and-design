# CS Program Portfolio - Project Reflection

## Project Artifacts

### Project One - Runtime and Memory Analysis
For Project One, I performed a detailed analysis of the runtime and memory efficiency for three primary data structures: **Vector**, **Hash Table**, and **Binary Search Tree**. This analysis helped me evaluate which structure would best fit the requirements of an advising program that retrieves course information quickly and efficiently.

### Project Two - Course Sorting and Display Code
In Project Two, I implemented a command-line C++ program to load, sort, and display a list of computer science courses in alphanumeric order. This functionality enables academic advisors to access a structured and sorted list of courses directly from the command line, improving the program’s usability and reliability.

## Reflection

### What was the problem you were solving in the projects for this course?
The main problem I addressed in these projects was to create an advising assistance system that would allow academic advisors at ABC University to retrieve and manage course information. The program had to efficiently handle a large list of courses, display them in alphanumeric order, and provide specific course information along with prerequisites when needed. This required careful planning around data structure choice to ensure quick access and retrieval of course data.

### How did you approach the problem? Why are data structures important to understand?
I approached the problem by carefully evaluating and selecting the data structures that would best serve each requirement of the program. In Project One, I compared the **Vector**, **Hash Table**, and **Binary Search Tree** data structures to determine which would most effectively handle insertion, search, and display operations for a large dataset. **Data structures** are essential because they determine the efficiency of data manipulation and retrieval within a program. By selecting the most appropriate structure, I was able to optimize for quick access and minimal memory usage, enhancing the program's performance and user experience.

### How did you overcome any roadblocks you encountered while going through the activities or project?
One significant roadblock was ensuring that the program handled **edge cases** and user errors smoothly. For example, the program needed to manage cases where input data might be missing or incorrectly formatted, such as non-existent course prerequisites. I addressed this by implementing validation checks and clear error messages, guiding users to correct inputs without causing program crashes. This iterative problem-solving helped refine my approach to error handling and reinforced the importance of making programs user-friendly and resilient.

### How has your work on this project expanded your approach to designing software and developing programs?
Working on this project expanded my understanding of **modular software design** and reinforced the benefits of structuring code for scalability and flexibility. I learned to break down complex tasks into smaller, manageable modules, such as creating separate functions for loading data, validating input, and displaying course information. This approach ensures that each part of the program remains functional and easily modifiable. I also gained experience in designing a user interface with a command-line menu, enhancing my ability to balance technical requirements with user experience considerations.

### How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
This project helped me refine my approach to writing **clean, well-documented code**. By adhering to industry-standard best practices, such as using meaningful variable names and including inline comments, I’ve improved my code’s readability and maintainability. I also used consistent indentation and function separation to ensure that future developers or collaborators can easily understand and modify the code. These habits have evolved my programming style, making it more adaptable for various applications and larger projects.

## How to Run the Project

To test the code locally:
1. Clone the repository.
2. Open `ProjectTwo.cpp` in your preferred C++ IDE.
3. Compile and run the program from the command line.
4. Follow the prompts to test each menu option and ensure all data loads and displays correctly.

Thank you for reviewing my portfolio submission.
